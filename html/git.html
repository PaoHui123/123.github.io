<!DOCTYPE html>
<html lang="zh-CN">
<!--告诉浏览器该网站的语言-->

<head>
    <meta charset="utf-8">
    <!--万国码-->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 样式 -->
    <link rel="stylesheet/less" type="text/css" href="./less/style.less">

    <!-- 引入代码高亮的主题css -->
    <link rel="stylesheet" type="text/css" href="../lib/highlight/styles/atom-one-dark.min.css">

    <!-- 引入代码样式代码 -->
    <link rel="stylesheet" type="text/css" href="./css/highlight.css">

    <!-- 引入目录代码样式 -->
    <link rel="stylesheet" type="text/css" href="../lib/dist/tocbot.css">
    <title>git</title>
    <style>

    </style>

</head>

<body>





    <div class="aside">
        <div class="aside1 ">
            <ul>
                <li>
                    <h3>html框架</h3>
                </li>
                <li><a href="#" class="aside_a">1111</a></li>
                <li><a href="#" class="aside_a">1111</a></li>
            </ul>
            <span>目录</span>
            <ol class="js-toc"></ol>
        </div>
    </div>




    <div class="zhuTi js-toc-content">
        mkdir a b c //分别创建 a文件夹 b文件夹 c文件夹
        <h3>备注</h3>
        <div>
            <pre><code>
# 链接远程仓库
git remote add origin https://github.com/PaoHui123/123.git

# 删除远程链接
git remote rm origin

# 查看远程链接
git remote -v

# 克隆代码
git clone 项目地址

# 提交远程仓库
git push 远程链接名称

# 创建新分支
git branch 分支名

#  合并分支 将名称为name的分支与当前分支合并
git merge name

# 更改远程仓库  后面的网址就是新的远程仓库
$ git remote set-url origin https://gitee.com/dd223344/enjoy-plus.git
            </code></pre>
        </div>

        

        <h2>整理完好</h2>
        <div>
            <pre><code>
1.安装：GitLens
# 此插件可以显示他人的提交记录

2.快捷键打开终端：ctrl+`

3.cd 项目文件下；如cd gitlab/learngit

4.命令行：创建版本库，版本提交，版本回退，管理修改，撤销修改，删除文件

0、创建版本库（选择一个合适的地方,创建一个空目录gitlab/learngit。进入gitlab/learngit文件夹中）
    $ cd gitlab/learngit
    $ git init // 通过git init命令把这个目录变成Git可以管理的仓库
    或者直接拉取克隆版本库项目
    $ git clone 链接，类似git@github.com：yourname/test.git的

1、版本提交
    git add <文件名或文件夹名称>文件名或文件夹名称或者 . 代表所有
    git commit -m "这次的提交描述备注"
    git status 查看提交修改的文件
    git branch 查看当前分支
    git branch <分支名字>创建分支
    git checkout <分支名字>切换分支
    git merge <分支名字>（不是当前的分支）合并某分支到当前分支
    git branch -d <分支名字>删除分支
    $ git push origin master 上传本地指定分支到远程仓库
    $ git pull [branch] 取回远程仓库的变化，并与本地分支合并

2、版本回退
    回退到上一个版本（可以多次使用）
    $ git reset --hard HEAD^
    回退到上两个版本
    $ git reset --hard HEAD^^
    git log查看提交历史，然后git reset 回退到指定版本 。这也是每次commit -m" "中写内容的重要性，说不定什么时候就拯救了你写了好几天的代码。hard后面跟的版本号没必要全部写出来，git会自动去补全匹配。
    $ git log 
    $ git reset --hard 

3、管理修改
    我们来一个操作，第一次修改 -> git add -> 第二次修改 -> git commit
    然后git status查看状态，咦，怎么第二次的修改没有被提交？
    Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。
    提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别。
    那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：
    第一次修改 -> git add -> 第二次修改 -> git add -> git commit

4、撤销修改
    $ git checkout -- readme.txt
    令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
    一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
    一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
    总之，就是让这个文件回到最近一次git commit或git add时的状态。
    git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令。

5、删除文件
    $ git rm test.txt
    $ git commit -m "remove test.txt"

**bug分支**
情景：undong.txt 工作还没做完（暂存区有很多add文件，这时还没有commit），这时接收到一个必须在两小时内完成的bug文件（和之前的工作无关）
    1 这时就要保存工作现场 git stash
    2 添加新分支 git branch fixbug
    3 切换到这个分支 git checkout fixbug
    4 git add bug文件
    5 提交 git commit
    6 删除该分支（一般情况应该合并）
    查看分支现场 git
    7 修复之前的分支 git stash pop
            </code></pre>
            <br><br><br>
        </div>


        <h2>1.远程仓库相关命令</h2>
        <div>
            <pre><code>
1.远程仓库相关命令
    检出仓库：$ git clone git://github.com/jquery/jquery.git
    查看远程仓库：$ git remote -v
    添加远程仓库：$ git remote add [name] [url]
    删除远程仓库：$ git remote rm [name]
    修改远程仓库：$ git remote set-url --push[name][newUrl]
    拉取远程仓库：$ git pull [remoteName] [localBranchName]
    推送远程仓库：$ git push [remoteName] [localBranchName]
            </code></pre>
            <br><br><br>
        </div>


        <h2>2.分支(branch)操作相关命令</h2>
        <div>
            <pre><code>
查看本地分支：$ git branch
查看远程分支：$ git branch -r
创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支
切换分支：$ git checkout [name]
创建新分支并立即切换到新分支：$ git checkout -b [name]
删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项
合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并
创建远程分支(本地分支push到远程)：$ git push origin [name]
删除远程分支：$ git push origin :heads/[name]
我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了

如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。
$ git push origin test:master // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支
$ git push origin test:test // 提交本地test分支作为远程的test分支

如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。
$ git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心            
            </code></pre>
            <br><br><br>
        </div>


        <h2>3.版本(tag)操作相关命令</h2>
        <div>
            <pre><code>
3.版本(tag)操作相关命令
    查看版本：$ git tag
    创建版本：$ git tag [name]
    删除版本：$ git tag -d [name]
    查看远程版本：$ git tag -r
    创建远程版本(本地版本push到远程)：$ git push origin [name]
    删除远程版本：$ git push origin :refs/tags/[name]
            </code></pre>
            <br><br><br>
        </div>


        <h2>4.子模块(submodule)相关操作命令</h2>
        <div>
            <pre><code>
子模块(submodule)相关操作命令
添加子模块：$ git submodule add [url] [path]
如：$ git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs
初始化子模块：$ git submodule init ----只在首次检出仓库时运行一次就行
更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下
删除子模块：（分4步走哦）
1)$ git rm --cached [path]  
            </code></pre>
            <br><br><br>
        </div>

        <h2>5.编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</h2>
        <div>
            <pre><code>

            </code></pre>
            <br><br><br>
        </div>

        <h2>6.编辑“.git/config”文件，将子模块的相关配置节点删除掉</h2>
        <div>
            <pre><code>

            </code></pre>
            <br><br><br>
        </div>

        <h2>7.手动删除子模块残留的目录</h2>


        <br><br><br><br><br><br>


        



        <h2>配置邮箱-姓名</h2>
        <div>
            1. 需要再用命令, 配置下, 你本机提交任何仓库时, 你的提交信息
            <br>2. 无论哪个项目/哪个仓库, 你都要表明你的<span class="red">身份名字</span>和<span class="red">邮箱</span>
            <br>3. 命令格式如下: ==中文自己看情况换==
            <pre><code>
git config --global user.name  "名字双引号，中文英文都可以"
git config --global user.email "双引号，写邮箱地址"

# 查看是否配置成功
git config --list
            </code></pre>
            <br><br><br>
        </div>





        <h2>创建git版本库-初始化</h2>
        <div>
            <p>1. 我们新建一个文件夹 / 现有的文件夹 是git仓库吗? 不是!!!</p>
            <p>因为没有 .git 文件夹, 所以没有被git管理</p>
            <br>
            <P>2. 新文件夹 / 现有文件夹, 可以运行如下命令, 得到.git文件夹, 即可让git开始准备管理</P>
            <pre><code>
# 初始化 git 仓库
git init
            </code></pre>
            <br><br><br>
        </div>


        <h2>放到暂存区中</h2>
        <div>
            <pre><code>
# 语法
git add 要暂存的文件名

# (了解) 将index.html 添加到暂存区
git add index.html

# 将css目录下一切添加到暂存区
git add css

# 一次性把所有变化文件, 放入暂存区
git add .

# 提交的内容说明
git commit -m '提交的内容说明'
            </code></pre>
        </div>

        <h2>查看所有提交的日志记录</h2>
        <div>
            <pre><code>
# 查看所有提交的日志记录
git log

# 当我们的日志越来越多, 可能想要简化查看
git log --oneline
            </code></pre>
        </div>

        <h2>查看修改了那些文件</h2>
        <div>
            <pre><code>
# 查看修改了那些文件
git status
            </code></pre>
        </div>

        <h2>git回退</h2>
        <div>
            1. 我们玩游戏, 突然感觉没玩好, 想要回到上次存档的记录重新来? 可以!!
            <br>2. 代码写到后面发现, 最近这2天的需求写错了, 回到2天前? 可以!!
            <br>3. 但是以上的回退前提, 你前面确实commit存档过 (而且存到的.git文件夹要存在)
            <br>4. 回退命令语法如下, 中文看情况写
            <pre><code>
# git回退
git reset --hard 版本号

# 尝试回退到 a3bcab2 这次记录上
git reset --hard a3bcab2
            </code></pre>
        </div>

        <h2>查看版本号</h2>
        <div>
            每次的版本号随机生成
            <pre><code>
# 查看版本号
git log --oneline
            </code></pre>
        </div>


        <h2>查看 git 所有的操作记录, 包括你的reset记录</h2>
        <div>
            <pre><code>
git reflog
            </code></pre>
            <br>
        </div>


        <h2>查看Head标记</h2>
        <div>
            <p>HEAD 是头指针, 可以指向标记现在工作区所在的记录</p>
        </div>


        <h2>git忽略文件</h2>
        <div>
            1. 有的时候, 我们某些文件/文件夹, 不想让git进行跟踪管理
            <br>2. 这种场景下, 我们需要在.git文件夹隔壁, 来个叫做 <span class="red">.gitignore</span> (固定名字)的忽略文件, 并写入忽略规则
            <br>3. 可以编写如下这些规则
            <pre><code>
# 忽略某个指定文件
password.txt

# 忽略文件夹
css

# 忽略文件夹下的某个文件
css/index.js

# 忽略文件夹下某类文件
css/*.js
            </code></pre>
        </div>


        <h2>分支创建的命令和特点</h2>
        <h2>创建分支</h2>
        <div>
            <p></p>
            <pre><code>
# 创建分支
git branch 分支名
            </code></pre>
        </div>

        <h2>查看现在这个.git版本库里所有分支</h2>
        <div>
            <p>可以运行命令查看现在这个.git版本库里所有分支</p>
            <pre><code>
# 查看当前版本库所有分支
git branch
# 绿色带*代表, 你现在所处的分支           
            </code></pre>
        </div>

        <h2>切换分支</h2>
        <div>
            <p>==注意: 第一次创建并切换到此分支==, 这里你会发现master分支上的所有代码(和当前节点所有提交记录) 都被复制了过来, 在这个基础上, 接着往后开发就行, 不是你的页面不同碰!!</p>
            <pre><code>
# 切换分支命令
git checkout 分支名                
            </code></pre>
        </div>

        <h2>切换到分支</h2>
        <div>
            <p>1. 当我们某个分支的业务开发完毕以后呢, 我们可以把分支里写好的代码, 合并到主分支/其他分支上
                <br>2. 首先, 切换到你要合并到的目标分支上, 这里以master主分支为例
            </p>
            <pre><code>
# 切换分支
git checkout master
            </code></pre>
        </div>

        <h2>合并分支命令</h2>
        <div>
            <pre><code>
# 把目标分支名下的所有记录, 合并到当前分支下
git merge 目标分支名                                
            </code></pre>
        </div>


        <h2>分支冲突</h2>
        <div>
            <p>出现分支冲突,与人商量</p>
        </div>


        <h2>删除分支</h2>
        <div>
            <p>1. 假如注册功能开发完毕, 代码已经合并到master分支上, 我们无需reg分支</p>
            <pre><code>
git branch -d 分支名
            </code></pre>
            <p>如果你当前分支代码 还有没合并到别的分支的, 则会报错</p>
        </div>

        <h2>git全局配置-删除</h2>
        <div>
            <pre><code>
# 1. git全局配置删除命令
# user.name 可以视情况删除哪个自己选
git config --unset --global user.name
            </code></pre>
        </div>


        <h2>vscode中文件右侧标记</h2>
        <div>
            <p>一般打开一个包含git仓库的文件夹时, 会有这些标记</p>
            <pre><code>
右侧没有标记的时候为“未修改” 或 此文件/文件夹, 被git忽略不跟踪变化
M为“已修改”
A为“已添加”
D为“已删除”
R为“已重命名”
C为“已复制”
U为“已更新但为融合”
            </code></pre>
        </div>


        <h2>git restore 目标文件</h2>
        <div>
            <p>git还原 (会把"工作区"恢复到上次提交的时候), 并删除刚写的所有代码(无法找回)</p>
            <p>非常危险</p>
        </div>


        <h2>git版本回退更多</h2>
        <div>
            <pre><code>
# 除了找到对应版本号之外, 我们还可以用内置的代号
# 回退到 "最近一次提交" (但是要注意如果你已经回退了, 是回不到未来的, 回到未来需要指定
版本号数字字母)
git reset --hard head~0
# 回退到 "上一次提交"
git reset --hard head~1
# 回退到 "上上次提交"
git reset --hard head~2
# 想退多少次, 先用git log --oneline 打印后根据注释信息, 自己数下回退几次 head~后面写几


以上命令还有个写法
# 回退到 "上一次提交"
git reset --hard head^
# 回退到 "上上次提交"
git reset --hard head^^
# 如果回退的太远, 一百个往前, 你不能写一百个^吧, 还是写head~个数吧
            </code></pre>
        </div>




        <h2>git版本回退-更优解</h2>
        <div>
            <p>reset其实会把未来的丢失掉, 如果推到远程仓库可能会有问题 (看下面情况做吧), 但是其实保证大家维护的同一个项目工程都是最新代码即可</p>
            <p>比reset更好用的revert</p>
            <p>如果已经有A -> B -> C，想回到B：</p>
            <p>方法一：reset到B，丢失C：</p>
            <p>A -> B</p>
            <p>方法二：再提交一个revert反向修改，变成B：</p>
            <p>A -> B -> C -> B</p>
            <p>C还在，但是两个B是重复的</p>
            <p>看你的需求，也许C就是瞎提交错了（比如把密码提交上去了），必须reset</p>
            <p>如果C就是修改，现在又要改回来，将来可能再改成C，那你就revert</p>
        </div>



        <h2>git常用忽略配置</h2>
        <div>
            <pre><code>
.DS_Store
node_modules/
dist/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json
yarn.lock
mock
# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
            </code></pre>
        </div>



        <h2>Gitee</h2>

        <h3>1.为了把本地项目（被git管理）放在公共平台（开源）</h3>

        <h3>配置SSH公钥私钥</h3>
        <p>**ssh-keygen -t rsa -b 4096 -C "写自己注册gitee邮箱地址" 提前改好再复制到你的黑窗口**</p>

        <h2>新建远程仓储</h2>

        <h2>设置开源</h2>

        <h2>在本地项目设置 与远程仓储的关联</h2>

        <h2>来到本地电脑 下 要推送这个项目 黑窗口里面 输入下面命令</h2>
        <pre><code>
git  remote   add     origin           SSH地址
     配置远程   新增    给远程地址起别名   远程仓库地址
        </code></pre>

        <h2>推送本地项目到远程仓库</h2>
        <div>
            <pre><code>
git push  -u  origin     master
    推送      远程地址别名  主分支

git push
后续
            </code></pre>
        </div>

        <h2>总结</h2>
        <div>
            <pre><code>
* 新电脑：

  * 安装git软件
  * 配置个人信息：做一次就行！

  ```
  git config --global user.name  "用户名"
  git config --global user.email "邮箱地址"
  ```

* 学会申请gitee:把本地生成公钥私钥，配置给个人gitee空间；（对gitee个人空间有操作权，所有项目）

---



* 项目初始化开始：初始化一个空git仓库  `git init`
* 项目开发：
  * 添加文件到暂存区 `git add .`
  * 本地项目文件夹配置 忽略文件  .gitignore 
  * 把暂存区记录添加到git仓库   `git commit -m "本次提交的备注，一定要写"`
* 远程：
  * 新建远程仓库
  * 回到本地设置关联：`git remote add origin SSH地址`   （对于项目来讲，关联一次就OK）
  * 把本地所有记录 推送到远程 
    * 第一次：`git push -u origin master`
    * 后续：`git push`
  * 新人：
    * 到了公司，先让组长给发一个 成员邀请链接！成为私有仓库的开发人员；
    * 克隆远程仓库到本地  `git clone SSH地址`（注意黑窗口的地址和项目地址不一样）
    * 进入项目：`cd 项目文件夹  `  （不是git命令）
* 全体人员push：
  * 1、组长和组员都有项目了！
  * 2、创建新分支：`git branch 分支名`
  * 3、切换到分支  `git checkout 分支名`
  * 4、继续开发代码，形成commit记录点，只是存在当前分支上
  * 5、测试代码，通过；
  * 6、回到业务分支上  master分支；合并`git merge 分支名`
    * 冲突了怎么办？解决冲突！删除符号，再提交！（出现几率非常小！）
    * 真实：各自完成自己单独功能和页面（相互之间不影响）解释下为什么要合并！
  * 7、是不是相当于在master 上华丽添加了一个功能；
  * 8、推送到远程 `git push `

* 全体人员pull: 

  * 1、git pull 本地项目和远程进行同步； 在认定master主分支上pull；你自己代码在你自己分支上！
  * 2、远程没有更新`Already up to date.`  本地和远程是一样记录点！
  * **也就是上传代码之前    先保证在主分支上拿到最新代码再合并分支
            </code></pre>
        </div>





        <h2>标题</h2>
        <div>
            <table border="3" cellspacing="0" cellpadding="3">
                <caption>列表</caption>
                <tr>
                    <th>功能</th>
                    <th>用法</th>
                    <th>备注</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <br><br><br>
        </div>


















    </div>

</body>



<script>



</script>

<!-- 引入js文件 -->
<script src="./js/html.js"></script>

<!-- 浏览器读取less文件的js -->
<script src="../lib/less.js"></script>



<!-- 引入代码高亮的js文件 -->
<script src="../lib/highlight/highlight.min.js"></script>
<!-- highlight使用方式:   -->
<!-- <pre><code class="语言">需要高亮的代码</code></pre> -->
<!-- 类名不写语言默认自动识别 -->

<!-- 初始化代码高亮 -->
<script>hljs.initHighlightingOnLoad();</script>



<!-- 引入代码显示行数的js文件 -->
<script src="../lib/highlightjs-line-numbers.js-master/highlightjs-line-numbers.js"></script>

<!-- 初始化代码显示高度 -->
<script>hljs.initLineNumbersOnLoad({ singleLine: true });</script>

<!-- 自动生成目录 -->
<script src="../lib/dist/tocbot.min.js"></script>
<script type="text/javascript">
    //目录生成初始化
    tocbot.init({
        // 在何处呈现目录。
        tocSelector: '.js-toc',

        // 在何处获取标题以构建目录。
        contentSelector: '.js-toc-content',

        // 要在内容选择器元素内获取哪些标题。
        headingSelector: 'h2,h3,h4',//对h2和h3元素进行生成目录

        //对于内容中相对或绝对位置的容器内的标题。
        hasInnerContainers: true,
    });
</script>



</body>

</html>